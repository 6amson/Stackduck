
syntax = "proto3";
package jobqueue;

service JobQueueService {
  rpc EnqueueJob(EnqueueJobRequest) returns (EnqueueJobResponse);
  rpc DequeueJob(DequeueJobRequest) returns (DequeueJobResponse);
  rpc CompleteJob(CompleteJobRequest) returns (CompleteJobResponse);
  rpc FailJob(FailJobRequest) returns (FailJobResponse);
  rpc RetryJob(RetryJobRequest) returns (RetryJobResponse);
  rpc GetJobStatus(GetJobStatusRequest) returns (GetJobStatusResponse);
  
  // Streaming for workers - this is the "broadcast" mechanism
  rpc ConsumeJobs(ConsumeJobsRequest) returns (stream JobMessage);
  
  // Worker registration (optional but useful for monitoring)
  rpc RegisterWorker(RegisterWorkerRequest) returns (RegisterWorkerResponse);
}

message Job {
  string id = 1;
  string job_type = 2;
  string payload = 3; // JSON string
  string status = 4;
  int32 priority = 5;
  int32 retry_count = 6;
  int32 max_retries = 7;
  int64 scheduled_at = 8; // Unix timestamp
  int64 started_at = 9;
  int64 completed_at = 10;
  int64 created_at = 11;
  int64 updated_at = 12;
}

message EnqueueJobRequest {
  string job_type = 1;
  string payload = 2;
  int32 priority = 3;
  int32 max_retries = 4;
  int64 scheduled_at = 5; // Optional - for delayed jobs
}

message EnqueueJobResponse {
  string job_id = 1;
  bool success = 2;
  string error_message = 3;
}

message DequeueJobRequest {
  string queue_name = 1;
  int32 timeout_seconds = 2;
}

message DequeueJobResponse {
  Job job = 1;
  bool success = 2;
}

message ConsumeJobsRequest {
  string worker_id = 1;
  repeated string job_types = 2; // Which job types this worker can handle
}

message JobMessage {
  Job job = 1;
  string worker_id = 2; // Which worker should process this
}

message CompleteJobRequest {
  string job_id = 1;
}

message CompleteJobResponse {
  bool success = 1;
}